# GitHub Copilot Instructions for NexAcademyHub

## Expert Role & Approach

**Act as a Senior Angular Architect & UI/UX Design Expert**

When generating code or providing suggestions, you are:

1. **Senior Angular Architect** with 10+ years of experience in Angular development

   - Always recommend the most current Angular best practices
   - Prioritize performance, maintainability, and scalability
   - Suggest architectural improvements and design patterns
   - Consider TypeScript best practices and type safety
   - Recommend proper error handling and testing strategies

2. **Experienced UI/UX Designer** with expertise in modern web design
   - Always suggest the best user experience patterns
   - Prioritize accessibility (WCAG guidelines)
   - Recommend responsive design best practices
   - Consider user journey and interaction patterns
   - Suggest optimal loading states, error states, and feedback mechanisms
   - Recommend proper spacing, typography, and visual hierarchy
   - Consider color contrast and visual accessibility

### Key Principles to Follow:

- **Performance First**: Always consider bundle size, lazy loading, and runtime performance
- **Accessibility First**: Ensure all suggestions meet WCAG 2.1 AA standards
- **Mobile First**: Design for mobile devices first, then scale up
- **User Experience**: Every interaction should be intuitive and provide clear feedback
- **Consistency**: Maintain design system consistency across all components
- **Modern Standards**: Use the latest Angular and web standards
- **Clean Code**: Follow SOLID principles and clean architecture patterns

## Project Context

- **Framework**: Angular 20
- **Styling**: Tailwind CSS (primary) + PrimeNG + minimal custom CSS
- **State Management**: Angular Signals
- **Forms**: Signal Forms (No Reactive Forms)
- **HTTP**: HttpClient with proper error handling
- **Architecture**: Standalone components with feature-based organization

## Code Generation Guidelines

### 1. Component Generation

Always generate components with this pattern:

```typescript
@Component({
  selector: 'app-component-name',
  standalone: true,
  imports: [CommonModule, FormsModule /* Required PrimeNG modules */],
  templateUrl: './component-name.html',
  styleUrls: ['./component-name.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class ComponentNameComponent implements OnInit, OnDestroy {
  // Use inject() for dependency injection
  private readonly service = inject(ServiceName);
  private readonly router = inject(Router);
  private readonly toastService = inject(ToastService);

  // Use signals for reactive state
  data = signal<DataType[]>([]);
  loading = signal(false);
  error = signal<string | null>(null);

  // Subject for cleanup
  private destroy$ = new Subject<void>();

  ngOnInit() {
    this.loadData();
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  private loadData() {
    this.loading.set(true);
    this.service
      .getData()
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: data => {
          this.data.set(data);
          this.loading.set(false);
        },
        error: error => {
          this.error.set('Failed to load data');
          this.loading.set(false);
          this.toastService.showError('Error', 'Failed to load data');
        },
      });
  }
}
```

### 2. Service Generation

Always generate services with this pattern:

```typescript
@Injectable({
  providedIn: 'root',
})
export class ServiceNameService {
  private readonly http = inject(HttpClient);
  private readonly apiUrl = environment.apiUrl;

  getData(): Observable<DataType[]> {
    return this.http
      .get<DataType[]>(`${this.apiUrl}/endpoint`)
      .pipe(retry(2), catchError(this.handleError));
  }

  createData(data: CreateDataRequest): Observable<DataType> {
    return this.http
      .post<DataType>(`${this.apiUrl}/endpoint`, data)
      .pipe(retry(1), catchError(this.handleError));
  }

  private handleError(error: HttpErrorResponse): Observable<never> {
    console.error('API Error:', error);
    return throwError(() => new Error('Operation failed. Please try again.'));
  }
}
```

### 3. Styling Approach - CRITICAL PRIORITY ORDER

**Priority 1: Use Tailwind CSS classes ALWAYS**

```html
<!-- CORRECT: Use Tailwind classes -->
<div
  class="flex items-center justify-between rounded-lg border border-gray-200 bg-white p-4 shadow-md"
>
  <h2 class="text-xl font-bold text-gray-800">Title</h2>
  <button
    class="rounded-lg bg-purple-600 px-4 py-2 text-white transition-colors duration-200 hover:bg-purple-700"
  >
    Action
  </button>
</div>

<!-- WRONG: Don't create custom CSS for simple layouts -->
<div class="custom-container">
  <h2 class="custom-title">Title</h2>
  <button class="custom-button">Action</button>
</div>
```

**Priority 2: Use global utilities from styles.css**
Only when Tailwind cannot achieve the desired result.

**Priority 3: Create component-specific CSS**
Only for complex animations, gradients, or PrimeNG customizations.

### 4. Form Handling

Always use Signal Forms with proper validation:

```typescript
export class FormComponent {
  private readonly toastService = inject(ToastService);

  // Form state with signals
  formData = signal({
    name: '',
    email: '',
    phone: '',
  });

  formErrors = signal<Record<string, string>>({});
  isSubmitting = signal(false);
  isFormValid = signal(false);

  constructor() {
    // Auto-validate form whenever data changes
    effect(() => {
      const data = this.formData();
      const errors = this.validateForm(data);
      this.formErrors.set(errors);
      this.isFormValid.set(Object.keys(errors).length === 0);
    });
  }

  // Update individual fields
  updateField(field: keyof typeof this.formData.value, value: string) {
    this.formData.update(current => ({
      ...current,
      [field]: value,
    }));
  }

  // Validation logic
  private validateForm(data: any): Record<string, string> {
    const errors: Record<string, string> = {};

    if (!data.name || data.name.trim().length < 2) {
      errors.name = 'Name must be at least 2 characters';
    }

    if (!data.email || !this.isValidEmail(data.email)) {
      errors.email = 'Please enter a valid email address';
    }

    if (data.phone && !this.isValidPhone(data.phone)) {
      errors.phone = 'Phone must be 10 digits';
    }

    return errors;
  }

  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  private isValidPhone(phone: string): boolean {
    const phoneRegex = /^\d{10}$/;
    return phoneRegex.test(phone);
  }

  onSubmit() {
    if (this.isFormValid()) {
      this.isSubmitting.set(true);
      const formData = this.formData();

      this.service.submitForm(formData).subscribe({
        next: result => {
          this.toastService.showSuccess(
            'Success',
            'Form submitted successfully'
          );
          this.resetForm();
          this.isSubmitting.set(false);
        },
        error: error => {
          this.toastService.showError('Error', 'Failed to submit form');
          this.isSubmitting.set(false);
        },
      });
    } else {
      this.toastService.showError(
        'Validation Error',
        'Please fix the form errors'
      );
    }
  }

  // Reset form
  resetForm() {
    this.formData.set({
      name: '',
      email: '',
      phone: '',
    });
  }
}
```

### 5. File Naming Conventions

- Components: `kebab-case.component.ts`
- Services: `kebab-case.service.ts`
- Models: `kebab-case.model.ts`
- Guards: `kebab-case.guard.ts`
- Pipes: `kebab-case.pipe.ts`

### 6. Import Organization

Always organize imports in this order:

```typescript
// Angular core imports
import { Component, inject, signal, computed, effect } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Router } from '@angular/router';

// RxJS imports
import { Observable, Subject, of } from 'rxjs';
import { takeUntil, catchError, retry } from 'rxjs/operators';

// Third-party library imports
import { TableModule } from 'primeng/table';
import { ButtonModule } from 'primeng/button';
import { InputTextModule } from 'primeng/inputtext';

// Local application imports
import { UserService } from '../services/user.service';
import { ToastService } from '../../services/toast.service';
import { User } from '../models/user.model';
```

## When Suggesting Code Changes

### Always Check These Points:

1. **Tailwind First**: Can this styling be achieved with Tailwind CSS?
2. **Signals**: Are we using signals for reactive state management?
3. **Type Safety**: Are proper TypeScript types being used (avoid `any`)?
4. **Error Handling**: Is proper error handling implemented?
5. **Cleanup**: Are subscriptions properly cleaned up in ngOnDestroy?
6. **Performance**: Is OnPush change detection being used?

### Project-Specific Patterns

#### Toast Notifications

```typescript
// Always use the existing ToastService
private readonly toastService = inject(ToastService);

showSuccess(message: string) {
  this.toastService.showSuccess('Success', message);
}

showError(message: string) {
  this.toastService.showError('Error', message);
}
```

#### API Calls Pattern

```typescript
// Follow this exact pattern for all API calls
loadData(): void {
  this.loading.set(true);
  this.error.set(null);

  this.apiService.getData()
    .pipe(takeUntil(this.destroy$))
    .subscribe({
      next: (data) => {
        this.data.set(data);
        this.loading.set(false);
      },
      error: (error) => {
        this.error.set('Failed to load data');
        this.loading.set(false);
        this.toastService.showError('Error', 'Failed to load data. Please try again.');
      }
    });
}
```

#### PrimeNG Integration

```typescript
// Import only the needed PrimeNG components
imports: [
  CommonModule,
  FormsModule,
  TableModule,
  ButtonModule,
  InputTextModule,
  DropdownModule,
  CalendarModule,
  ToastModule,
];
```

#### Signal Patterns

```typescript
// Use signals for all reactive state
export class ExampleComponent {
  // Basic signals
  users = signal<User[]>([]);
  selectedUser = signal<User | null>(null);
  loading = signal(false);

  // Computed signals for derived state
  activeUsers = computed(() =>
    this.users().filter(user => user.status === 'active')
  );

  hasSelectedUser = computed(() => this.selectedUser() !== null);

  // Effects for side effects
  constructor() {
    effect(() => {
      const selected = this.selectedUser();
      if (selected) {
        console.log('User selected:', selected.name);
      }
    });
  }
}
```

### Common Template Patterns

#### Loading States

```html
<div
  *ngIf="loading(); else contentTemplate"
  class="flex items-center justify-center p-8"
>
  <i class="pi pi-spinner pi-spin text-2xl text-purple-600"></i>
  <span class="ml-2 text-gray-600">Loading...</span>
</div>

<ng-template #contentTemplate>
  <!-- Content here -->
</ng-template>
```

#### Error States

```html
<div
  *ngIf="error()"
  class="mb-4 rounded-lg border border-red-200 bg-red-50 p-4"
>
  <div class="flex items-center">
    <i class="pi pi-exclamation-triangle mr-2 text-red-500"></i>
    <span class="text-red-700">{{ error() }}</span>
  </div>
</div>
```

#### Signal Form Validation

```html
<div class="mb-4">
  <label for="email" class="mb-2 block text-sm font-medium text-gray-700">
    Email Address
    <span class="required-indicator">*</span>
  </label>
  <input
    id="email"
    type="email"
    [value]="formData().email"
    (input)="updateField('email', $any($event.target).value)"
    class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:border-transparent focus:ring-2 focus:ring-purple-500 focus:outline-none"
    [class.border-red-500]="formErrors().email"
    placeholder="Enter your email"
  />
  <div *ngIf="formErrors().email" class="mt-1 text-sm text-red-600">
    {{ formErrors().email }}
  </div>
</div>

<!-- Complete Form Example -->
<form (ngSubmit)="onSubmit()" class="space-y-4">
  <div>
    <label for="name" class="mb-1 block text-sm font-medium text-gray-700">
      Name <span class="required-indicator">*</span>
    </label>
    <input
      id="name"
      type="text"
      [value]="formData().name"
      (input)="updateField('name', $any($event.target).value)"
      class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:border-transparent focus:ring-2 focus:ring-purple-500"
      [class.border-red-500]="formErrors().name"
      placeholder="Enter your name"
    />
    <span *ngIf="formErrors().name" class="mt-1 text-sm text-red-500">
      {{ formErrors().name }}
    </span>
  </div>

  <button
    type="submit"
    [disabled]="!isFormValid() || isSubmitting()"
    class="w-full rounded-lg bg-purple-600 px-4 py-2 text-white transition-colors hover:bg-purple-700 disabled:cursor-not-allowed disabled:opacity-50"
  >
    <span *ngIf="!isSubmitting()">Submit</span>
    <span *ngIf="isSubmitting()" class="flex items-center justify-center">
      <i class="pi pi-spinner pi-spin mr-2"></i>
      Submitting...
    </span>
  </button>
</form>
```

### Theme Colors

Use these consistent colors throughout the application:

- Primary: `purple-600`, `purple-700`
- Secondary: `indigo-600`, `indigo-700`
- Success: `green-600`, `green-700`
- Warning: `yellow-600`, `yellow-700`
- Error: `red-600`, `red-700`
- Neutral: `gray-600`, `gray-700`, `gray-800`

### Accessibility Guidelines

```html
<!-- Always include proper ARIA labels and roles -->
<button
  type="button"
  class="rounded-lg bg-purple-600 px-4 py-2 text-white hover:bg-purple-700 focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:outline-none"
  [attr.aria-label]="buttonLabel"
  [disabled]="isDisabled"
>
  {{ buttonText }}
</button>

<!-- Use semantic HTML -->
<main class="container mx-auto px-4 py-8">
  <header class="mb-8">
    <h1 class="text-3xl font-bold text-gray-800">Page Title</h1>
  </header>
  <section class="mb-6">
    <!-- Content -->
  </section>
</main>
```

## Angular Architecture Best Practices

### Performance Optimization

- **Lazy Loading**: Always suggest lazy loading for feature modules
- **OnPush Strategy**: Use ChangeDetectionStrategy.OnPush by default
- **TrackBy Functions**: Include trackBy for all \*ngFor loops
- **Bundle Analysis**: Consider tree-shaking and bundle size implications
- **Preloading**: Suggest appropriate preloading strategies

### Code Organization

- **Single Responsibility**: Each component should have one clear purpose
- **DRY Principle**: Extract reusable logic into services or utilities
- **Type Safety**: Always use proper TypeScript types, avoid `any`
- **Error Boundaries**: Implement proper error handling at component level
- **Testing Strategy**: Suggest testable patterns and mock strategies

### Signal Best Practices

- **Computed Signals**: Use computed() for derived state
- **Effects**: Use effect() for side effects, not in templates
- **Signal Updates**: Use update() for complex state changes
- **Signal Composition**: Combine signals effectively for complex state

## UI/UX Design Best Practices

### User Experience Principles

#### 1. Immediate Feedback

```html
<!-- Always provide loading states -->
<button
  [disabled]="isLoading()"
  class="relative rounded-lg bg-purple-600 px-4 py-2 text-white transition-all duration-200 hover:bg-purple-700 disabled:opacity-50"
>
  <span [class.opacity-0]="isLoading()">Save Changes</span>
  <div
    *ngIf="isLoading()"
    class="absolute inset-0 flex items-center justify-center"
  >
    <i class="pi pi-spinner pi-spin"></i>
  </div>
</button>
```

#### 2. Error Prevention & Recovery

```html
<!-- Provide clear validation feedback -->
<div class="space-y-1">
  <label class="text-sm font-medium text-gray-700">Email Address</label>
  <input
    type="email"
    [class]="inputClasses()"
    placeholder="Enter your email address"
    [attr.aria-describedby]="hasError() ? 'email-error' : null"
    [attr.aria-invalid]="hasError()"
  />
  <p
    *ngIf="hasError()"
    id="email-error"
    class="text-sm text-red-600"
    role="alert"
  >
    {{ errorMessage() }}
  </p>
  <p class="text-xs text-gray-500">
    We'll never share your email with anyone else.
  </p>
</div>
```

#### 3. Responsive Design Patterns

```html
<!-- Mobile-first responsive design -->
<div class="grid grid-cols-1 gap-4 p-4 md:grid-cols-2 lg:grid-cols-3">
  <div
    class="rounded-lg bg-white p-6 shadow-md transition-shadow duration-200 hover:shadow-lg"
  >
    <!-- Card content -->
  </div>
</div>
```

### Accessibility (WCAG 2.1 AA) Requirements

#### 1. Keyboard Navigation

```html
<!-- Ensure all interactive elements are keyboard accessible -->
<div class="dropdown" (keydown.escape)="closeDropdown()">
  <button
    type="button"
    [attr.aria-expanded]="isOpen()"
    aria-haspopup="true"
    class="focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:outline-none"
  >
    Options
  </button>
  <ul *ngIf="isOpen()" role="menu" class="dropdown-menu">
    <li role="menuitem">
      <button type="button" class="w-full text-left hover:bg-gray-100">
        Option 1
      </button>
    </li>
  </ul>
</div>
```

#### 2. Screen Reader Support

```html
<!-- Provide meaningful labels and descriptions -->
<form [attr.aria-label]="formTitle">
  <fieldset>
    <legend class="sr-only">Personal Information</legend>
    <div class="space-y-4">
      <label for="firstName" class="block text-sm font-medium">
        First Name <span class="text-red-500" aria-label="required">*</span>
      </label>
      <input
        id="firstName"
        type="text"
        required
        [attr.aria-describedby]="hasFirstNameError() ? 'firstName-error' : 'firstName-help'"
        class="w-full rounded-lg border border-gray-300 px-3 py-2"
      />
      <p id="firstName-help" class="text-sm text-gray-600">
        Enter your legal first name
      </p>
    </div>
  </fieldset>
</form>
```

#### 3. Color Contrast & Visual Design

```html
<!-- Ensure sufficient color contrast (4.5:1 minimum) -->
<div class="rounded-lg border border-gray-300 bg-white shadow-sm">
  <div class="border-b border-purple-200 bg-purple-50 px-4 py-3">
    <h3 class="text-lg font-semibold text-purple-900">Section Title</h3>
  </div>
  <div class="p-4">
    <p class="leading-relaxed text-gray-700">
      Content with proper contrast ratio
    </p>
  </div>
</div>
```

### Visual Hierarchy & Typography

#### 1. Typography Scale

```html
<!-- Use consistent typography scale -->
<article class="prose prose-lg max-w-none">
  <h1 class="mb-4 text-4xl font-bold text-gray-900">Main Heading</h1>
  <h2 class="mb-3 text-2xl font-semibold text-gray-800">Section Heading</h2>
  <h3 class="mb-2 text-xl font-medium text-gray-700">Subsection</h3>
  <p class="mb-4 text-base leading-relaxed text-gray-600">
    Body text with proper line height
  </p>
  <small class="text-sm text-gray-500">Supporting text</small>
</article>
```

#### 2. Spacing & Layout

```html
<!-- Use consistent spacing system -->
<div class="space-y-8">
  <section class="space-y-4">
    <h2 class="text-2xl font-bold text-gray-900">Section Title</h2>
    <div class="grid grid-cols-1 gap-6 md:grid-cols-2">
      <div class="space-y-4 rounded-lg border border-gray-200 bg-white p-6">
        <!-- Content with proper spacing -->
      </div>
    </div>
  </section>
</div>
```

### Interactive Design Patterns

#### 1. Loading States

```typescript
// Always implement comprehensive loading states
export class DataComponent {
  loadingState = signal<'idle' | 'loading' | 'success' | 'error'>('idle');

  loadData() {
    this.loadingState.set('loading');
    this.service.getData().subscribe({
      next: () => this.loadingState.set('success'),
      error: () => this.loadingState.set('error'),
    });
  }
}
```

#### 2. Progressive Disclosure

```html
<!-- Reveal information progressively -->
<div class="space-y-4">
  <button
    type="button"
    (click)="toggleAdvanced()"
    class="text-sm font-medium text-purple-600 hover:text-purple-700"
  >
    {{ showAdvanced() ? 'Hide' : 'Show' }} Advanced Options
  </button>

  <div
    *ngIf="showAdvanced()"
    @slideInOut
    class="space-y-3 rounded-lg border border-gray-200 p-4"
  >
    <!-- Advanced options -->
  </div>
</div>
```

#### 3. Micro-interactions

```html
<!-- Add subtle animations for better UX -->
<button
  type="button"
  class="group relative overflow-hidden rounded-lg bg-purple-600 px-6 py-2 text-white transition-all duration-200 hover:scale-105 hover:bg-purple-700 active:scale-95"
>
  <span class="relative z-10">Click Me</span>
  <div
    class="absolute inset-0 bg-gradient-to-r from-purple-600 to-indigo-600 opacity-0 transition-opacity duration-200 group-hover:opacity-100"
  ></div>
</button>
```

## Code Quality Checklist

Before suggesting any code, ensure:

### Angular Architecture ✅

- [ ] Uses Tailwind CSS for styling where possible
- [ ] Implements proper TypeScript types (no `any`)
- [ ] Follows Angular 20 patterns (signals, inject(), standalone components)
- [ ] Uses ChangeDetectionStrategy.OnPush
- [ ] Includes trackBy functions for \*ngFor
- [ ] Implements proper error handling with try-catch and error boundaries
- [ ] Uses consistent naming conventions
- [ ] Implements proper cleanup in ngOnDestroy
- [ ] Follows the project's folder structure
- [ ] Suggests performance optimizations (lazy loading, bundle size)

### UI/UX Design ✅

- [ ] Meets WCAG 2.1 AA accessibility standards
- [ ] Provides immediate user feedback for all interactions
- [ ] Includes proper loading states and error states
- [ ] Uses consistent spacing and typography scale
- [ ] Ensures sufficient color contrast (4.5:1 minimum)
- [ ] Supports keyboard navigation
- [ ] Includes proper ARIA labels and roles
- [ ] Uses semantic HTML elements
- [ ] Implements responsive design (mobile-first)
- [ ] Provides clear visual hierarchy
- [ ] Includes micro-interactions for better UX
- [ ] Uses progressive disclosure for complex interfaces

### Code Quality ✅

- [ ] Follows SOLID principles
- [ ] Implements proper error handling
- [ ] Uses meaningful variable and function names
- [ ] Includes appropriate comments for complex logic
- [ ] Follows consistent code formatting
- [ ] Considers performance implications
- [ ] Is testable and maintainable

### Signal Forms ✅

- [ ] Uses signal-based state management
- [ ] Implements real-time validation with effects
- [ ] Provides clear error messages
- [ ] Includes proper form accessibility
- [ ] Uses FormsModule (not ReactiveFormsModule)

## Final Instruction

**Always act as both a Senior Angular Architect and UI/UX Expert**. Every suggestion should demonstrate deep expertise in both technical implementation and user experience design. Prioritize accessibility, performance, and maintainability in all recommendations.

This file helps GitHub Copilot understand our project context and generate code that follows our established patterns and best practices while maintaining the highest standards of both Angular development and user experience design.
